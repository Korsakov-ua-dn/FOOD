038 переключение межу табами бургер меню
window.addEventListener('DOMContentLoaded', () => {

    const tabs = document.querySelectorAll('.tabheader__item'),
          tabsContent = document.querySelectorAll('.tabcontent'),
          tabsParent = document.querySelector('.tabheader__items');
    
    function hideTabContent () {
        tabsContent.forEach(item => {
            item.style.display = 'none';
        });

        tabs.forEach(item => {
            item.classList.remove('tabheader__item_active');
        });
    }

    function showTabContent(i = 0) {
        tabsContent[i].style.display = 'block';
        tabs[i].classList.add('tabheader__item_active');
    }

    hideTabContent();
    showTabContent();

    tabsParent.addEventListener('click', (event) => {
        const target = event.target;

        if (target && target.classList.contains('tabheader__item')) {
            tabs.forEach((item, i) => {
                if (target == item) {
                    hideTabContent();
                    showTabContent(i);
                }
            });
        }
    });
});

039 Анимация, интервал и таймаут для выполнения скриптов
const btn = document.querySelector('.btn');
let timerId,
    i = 0;

function myAnimation () {
    const elem = document.querySelector('.box');
    let pos = 0;

    const id = setInterval(frame, 10);
    function frame () {
        if (pos == 300) {
            clearInterval(id);
        } else {
            pos++;
            elem.style.top = pos +"px";
            elem.style.left = pos +"px";
        }
    }
}

btn.addEventListener('click', myAnimation);

// function logger () {
//     if (i === 3) {
//         clearInterval(timerId);
//     }
//     console.log('text');
//     i++;
// }

// let id = setTimeout(function log() {
//     console.log('Hello');
//     id = setTimeout(log, 500);
// }, 500);

040 Работа с датами и временем
'use strict'

const now = new Date();

// console.log(now.getFullYear());
// console.log(now.getMonth());
// console.log(now.getDate());
// console.log(now.getDay()); // номер дня недели Пн - 1

// console.log(now.getHours()); // Местное время
// console.log(now.getUTCHours()); // +0 по гринвичу

// console.log(now.getTimezoneOffset()); // Разница между часовыми поясами в мин.
// console.log(now.getTime());

let start = new Date();

for (let i = 0; i < 100000; i++) {
    let some = i ** 3; // в ES7 ** - возводит в степень которая указана '3'
}

let end = new Date();

alert(`Цикл отработал за ${end - start} миллисекунд`)
// выводим в алерт время за которое отработал цикл

042 параметры документа, окна и работа с ними
'use strict'

const box = document.querySelector('.box');

const width = box.clientWidth.width;
const height = box.clientHeight.height;
console.log(width, height); /* отображает с учетом падингов но без ширины полосы прокрутки,
бордеров и марджинов */

const width = box.offsetWidth.width;
const height = box.offsetHeight.height;
console.log(width, height); /* отображает с учетом паддингов ширины полосы прокрутки 
бордеров и марджинов, но только видимую часть*/

const width = box.scrollWidth.width;
const height = box.scrollHeight.height;
console.log(width, height); /* без учета ширины полосы прокрутки но высоту 
всего проскролленного элемента*/

btn.addEventListener('click', ()=> {
    box.style.height = box.scrollHeight + 'px';

}); // Все предидущие значения нельзя изменить


console.log(box.scrollTop); /* сколько пикселей элемента уже было проскроллено
эту метрику можно изменять */

console.log(box.getBoundingClientRect().top); /* получаем все координаты элемента 
в виде объекта и можем использовать конкретное свойство .top*/

const style = window.getComputedStyle(box);
/* получаем все значения примененных css стилей к элементу,
 не путать с inline стилями */

console.log(style.display); // значение свойства display
console.log(document.documentElement.scrollTop);// то же действие для всего документа

window.scrollBy(0, 400) // скрол на 400px от текущей позиции
window.scrollTo(0, 400) // скрол на 400px от начала страницы

045 Функции конструкторы, создают объекты

function User(name, id) {
    this.name = name;
    this.id = id;
    this.human = true;
    this.hello = function() {
        console.log(`Hello ${this.name}`);
    };
}// функция конструирует новый объект

const ivan = new User('Ivan', 28);
const alex = new User('Alex', 30);

alex.hello();

// console.log(ivan);
// console.log(alex);

User.prototype.exit = function(name) {
    console.log(`Пользователь ${this.name} ушел`);
};// создаем новый метод у прототипа

ivan.exit();// работает только после создания метода у прототипа

046 Контекст вызова this
'use strict';
/* 1. Контекстом вызова обычной функции является window,
если 'use strict' то гтвукаштв
   2. this в конструкторах и классах - это новый экземпляр объекта
   3. ручная привязка this: call, apply, bind

const obj = {
    num: 5,
    sayNumber: function() {
        const say = () => {
            console.log(this);
        };
        say();
    }
};
obj.sayNumber();
/* контекст вызова this у обычной функции ссылается на объект внутри функции
   контекстом вызова у метода является сам объект
   контекстом вызова стрелочной функции будет ее родитель, своего нет
*/

const double = a => a * 2;/*тоже самое что и
const double = (a) {
    return a * 2;
};
Если стрелочная функция умещается на одной строке можно использ ее
укороченный вариант, так же если передается только один аргумент
можно записать без () */

btn.addEventListener('click', function() {
    this.style.backgroundColor = 'red';
});// this тоже самоечто event.target

function sayName(sername) {
    console.log(this);
    console.log(this.name + sername);
}
const user = {
    name: 'John'
};
sayName.call(user, 'Smith');
sayName.apply(user, ['Smith']);//тоже самое, разница в синтаксисе
/* функция преобрела контекст вызова благодаря методу call или apply
   ее контекстом стал объект user */

function count(num) {
    return this*num;
}
const double = count.bind(2);//bind создаеn новую фунцию к уже существующей
console.log(double(3));//d функцию double передаем один аргумент который будет удвоен

047 Классы, наследование
class Rectangle {
    constructor(height, width) {
        this.height = height;
        this.width = width;
    }
    calcArea() {
        return this.height * this.width;
    }
}
// const square = new Rectangle(10, 10);
// console.log(square.calcArea());

//Наследование классов, иерархия
class ColorRectangleWithText extends Rectangle {
    constructor(height, width, text, bgColor) {
        super(height, width);// просто() - все свойства родителя
        this.text = text;
        this.bgColor = bgColor;
    }
    showMyProps() {
        console.log(`Текст: ${this.text}, цвет: ${this.bgColor}`);
    }
}
const div = new ColorRectangleWithText(25, 10, 'jhjhfjdhf', 'red');
div.showMyProps();
console.log(div.calcArea());